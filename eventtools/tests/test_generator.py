# -*- coding: utf-8â€œ -*-
from django.test import TestCase
from _inject_app import TestCaseWithApp as AppTestCase
from eventtools_testapp.models import *
from datetime import date, time, datetime, timedelta
from _fixture import generator_fixture
from eventtools.utils import datetimeify
from dateutil.relativedelta import relativedelta
from django.core.urlresolvers import reverse

class TestGenerators(AppTestCase):
    
    def setUp(self):
        super(TestGenerators, self).setUp()
        generator_fixture(self)
    
    def test_generation(self):
        """
        Occurrences can be generated by a Generator. An event can have many Generators.
        A Generator has event, start datetime, end datetime, rule, repeat_until, and 'exceptions'.

        (`exceptions` is a JSONfield of start/end datetime pairs that the generator skips over if it was about to generate
        them).
        
        A generator generates occurrences by by repeating start/end datetimes according to the rule, until repeat_until is
        about to be exceeded.

        If repeat_until is omitted (and rule is set) then repetitions are created upto a preset period into the future.
        The preset is in settings. The preset period is continually updated.
        
        Every time a generator is saved, it does its generating.
        Every time an event is saved, generators with a rule and no repeat_until do their generating.

        A generator will not save occurrences for an event that are the same as occurrences already in the database (even
        if they were created by another generator). However, occurrences that differ only in start time or end time ARE
        generated,

        Occurrences are saved to the database, and have an FK to the generator that did so. The FK can be set to None so
        that an occurrence can be detatched from a generator.
        """

        # A generator without a rule generates one occurrence.
        self.ae(self.one_off_generator.occurrences.count(), 1)
        self.ae(self.weekly_generator.occurrences.count(), 5)
        
        self.assertTrue(self.endless_generator.occurrences.count() > 52)
        
        #test re-save event resaves 'boundless' generators.
        self.endless_generator.occurrences.all().delete()
        self.endless_generator.reset_exceptions()
        self.ae(self.endless_generator.occurrences.count(), 0)
        self.bin_night.save()
        self.assertTrue(self.endless_generator.occurrences.count() > 52)

        #test dupes are not created.
        self.ae(self.dupe_weekly_generator.occurrences.count(), 0)

    def test_all_day(self):
        """
        If the start time of a generator is time.min and the end time is time.max, then the generator generates all_day
        occurrences. If the start time of a generator is time.min and the end time is time.max and the repetition rule is
        hourly, then the generator generates one all_day occurrences followed by (e.g. 23 timed occurrences).
        """
        
        self.ae(self.all_day_generator.all_day, True)
        self.ae(self.weekly_generator.all_day, False)
        
        self.ae(self.all_day_generator.event_start, datetime(2010,1,4, 0, 0) )
        self.ae(self.all_day_generator.event_end, datetime.combine(date(2010,1,4), time.max) )
    
        self.ae(self.all_day_generator.occurrences.reverse()[0].start, datetime.combine(date(2010,1,25), time.min) )
        self.ae(self.all_day_generator.occurrences.reverse()[0].end, datetime.combine(date(2010,1,25), time.max) )
                
    def test_creation(self):
        """
        Same date/time constraints as occurrence.
        Attitionally, it is not valid to have a repeat_until without a rule.
        """
        e = self.bin_night
        d1 = date(2010,1,1)
        d2 = date(2010,1,2)
        d1min = datetimeify(d1, clamp='min')
        d1max = datetimeify(d1, clamp='max')
        d2min = datetimeify(d2, clamp='min')
        d2max = datetimeify(d2, clamp='max')
        t1 = time(9,00)
        t2 = time(10,00)
        
        dt1 = datetime.combine(d1, t1)
        dt2 = datetime.combine(d2, t2)

        #datetimes
        g = e.generators.create(event_start=dt1, event_end=dt2)
        self.ae(g.event_start, dt1)
        self.ae(g.event_end, dt2)

        g = e.generators.create(event_start=dt1)
        self.ae(g.event_start, dt1)
        self.ae(g.event_end, dt1)

        g = e.generators.create(event_start=d1min)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, d1max)

        
        #dates
        g = e.generators.create(event_start=d1)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, d1max)

        g = e.generators.create(event_start=d1, event_end=d2)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, d2max)

        #combos
        g = e.generators.create(event_start=dt1, event_end=d2)
        self.ae(g.event_start, dt1)
        self.ae(g.event_end, d2max)
        
        g = e.generators.create(event_start=d1, event_end=dt2)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, dt2)
        
        #missing event_start date
        self.assertRaises(TypeError, e.generators.create, **{'event_end':dt1})
        self.assertRaises(TypeError, e.generators.create, **{'event_end':d1})
        
        #invalid event_start value
        self.assertRaises(TypeError, e.generators.create, **{'event_start':t1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':t1, 'event_end':d1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':t1, 'event_end':dt1})

        #invalid event_end values
        self.assertRaises(TypeError, e.generators.create, **{'event_end':t1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':d1, 'event_end':t1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':dt1, 'event_end':t2})
        
        #event_start date later than event_end date
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':dt2, 'event_end':dt1})
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':d2, 'event_end':dt1})
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':d2, 'event_end':d1})
         
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':dt1, 'event_end':dt2, 'repeat_until':dt2})
        
    def test_exceptions(self):
        """
        If an occurrence is deleted, that occurrence's datetimes are added to the generator's exceptions. That prevents
        deleted occurrences from being regenerated.
        
        If an occurrence's generator FK is changed, that occurrence is added as an exception to the generator. That
        prevents reassigned/detatched occurrences from being regenerated.
        
        If an occurrence's event FK is changed, that occurrence is NOT added as an exception to the generator. That
        allows occurrences to be reassigned to eventvariations and for the generator to still apply.
        """
        
        #try with deleting
        self.ae(self.weekly_generator.exceptions, {})

        byebye_occ = self.weekly_generator.occurrences.all()[0]
        sdate = byebye_occ.start
        byebye_occ.delete()
        
        #check it gets added to exceptions
        self.weekly_generator = self.weekly_generator.reload()
        self.ae(self.weekly_generator.exceptions.keys(), [sdate.isoformat(),])
        
        #check it doesn't come back
        self.weekly_generator.generate()
        self.ae(self.weekly_generator.event.occurrences.filter(start=sdate).count(), 0)
        
        #now try with generator reassignment
        byebye_occ2 = self.weekly_generator.occurrences.all()[0]
        sdate2 = byebye_occ2.start
        byebye_occ2.generator = None
        byebye_occ2.save()
        self.weekly_generator = self.weekly_generator.reload()
        self.ae(self.weekly_generator.exceptions.keys(), [sdate.isoformat(), sdate2.isoformat()])

        #now try with event reassignment (which should NOT affect exceptions)
        byebye_occ3 = self.weekly_generator.occurrences.all()[0]
        bb3_id = byebye_occ3.id
        sdate3 = byebye_occ3.start
        byebye_occ3.event = self.furniture_collection
        byebye_occ3.save()
        #check it DOESN'T get added to exceptions
        self.weekly_generator = self.weekly_generator.reload()
        self.ae(self.weekly_generator.exceptions.keys(), [sdate.isoformat(), sdate2.isoformat()])
        
        #but also that it doesn't get regenerated.
        self.weekly_generator.generate()
        bb3 = TestGOccurrence.objects.get(id=bb3_id)
        self.assertTrue(bb3 in self.weekly_generator.occurrences.all())
        self.ae(bb3.event, self.furniture_collection)
        
        """
        When you change a generator and update existing occurrences:
          * we update the times of occurrences and exceptions to match the generator's times.
          * we generate occurrences as normal.
        This means that data is never lost except through an actual delete.


        If the generator's datetimes are modified, it is possible to update occurrence datetimes (where unmodified).
        If the generator's dates are modified, it is possible to update occurrence dates (where unmodified).
        If the generator's times are modified, it is possible to update occurrence times (where unmodified).
        If the generator is modified from being all-day to not all-day, it is possible to update (trivially).
        If the generator is modified from being not all-day to all-day, it is possible to update (trivially).

        If a generator's rule is changed, then no times are changed (unless as above), and no occurrences are deleted but any 'extra' occurrences are still generated.

        If a generator's repeat until value is changed then then no times are changed (unless as above), and no occurrences are deleted, but any 'extra' occurrences are still generated.
  
        Generators have a robot description.

        TODO: We need a special admin widget for entering the datetimes.
        """