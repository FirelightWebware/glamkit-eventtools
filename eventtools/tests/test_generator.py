# -*- coding: utf-8â€œ -*-
from django.test import TestCase
from _inject_app import TestCaseWithApp as AppTestCase
from eventtools_testapp.models import *
from datetime import date, time, datetime, timedelta
from _fixture import generator_fixture
from eventtools.utils import datetimeify
from dateutil.relativedelta import relativedelta
from django.core.urlresolvers import reverse
from eventtools.models import Rule

class TestGenerators(AppTestCase):
    
    def setUp(self):
        super(TestGenerators, self).setUp()
        generator_fixture(self)
    
    def test_generation(self):
        """
        Occurrences can be generated by a Generator. An event can have many Generators.
        A Generator has event, start datetime, end datetime, rule, repeat_until, and 'exceptions'.

        (`exceptions` is a JSONfield of start/end datetime pairs that the generator skips over if it was about to generate
        them).
        
        A generator generates occurrences by by repeating start/end datetimes according to the rule, until repeat_until is
        about to be exceeded.

        If repeat_until is omitted (and rule is set) then repetitions are created upto a preset period into the future.
        The preset is in settings. The preset period is continually updated.
        
        Every time a generator is saved, it does its generating.
        Every time an event is saved, generators with a rule and no repeat_until do their generating.

        A generator will not save occurrences for an event that are the same as occurrences already in the database (even
        if they were created by another generator). However, occurrences that differ only in start time or end time ARE
        generated,

        Occurrences are saved to the database, and have an FK to the generator that did so. The FK can be set to None so
        that an occurrence can be detatched from a generator.
        
        Generators have a robot description.
        """

        # A generator without a rule generates one occurrence.
        self.ae(self.one_off_generator.occurrences.count(), 1)
        self.ae(self.weekly_generator.occurrences.count(), 5)
        
        self.assertTrue(self.endless_generator.occurrences.count() > 52)
        
        #test re-save event resaves 'boundless' generators.
        self.endless_generator.occurrences.all().delete()
        self.endless_generator.reset_exceptions()
        self.ae(self.endless_generator.occurrences.count(), 0)
        self.bin_night.save()
        self.assertTrue(self.endless_generator.occurrences.count() > 52)

        #test dupes are not created.
        self.ae(self.dupe_weekly_generator.occurrences.count(), 0)

        self.ae(self.weekly_generator.robot_description(), "1 January 2010, 10:30-11:30am, repeating weekly until 29 January 2010")

    def test_all_day(self):
        """
        If the start time of a generator is time.min and the end time is time.max, then the generator generates all_day
        occurrences. If the start time of a generator is time.min and the end time is time.max and the repetition rule is
        hourly, then the generator generates one all_day occurrences followed by (e.g. 23 timed occurrences).
        """
        
        self.ae(self.all_day_generator.all_day, True)
        self.ae(self.weekly_generator.all_day, False)
        
        self.ae(self.all_day_generator.event_start, datetime(2010,1,4, 0, 0) )
        self.ae(self.all_day_generator.event_end, datetime.combine(date(2010,1,4), time.max) )
    
        self.ae(self.all_day_generator.occurrences.reverse()[0].start, datetime.combine(date(2010,1,25), time.min) )
        self.ae(self.all_day_generator.occurrences.reverse()[0].end, datetime.combine(date(2010,1,25), time.max) )
                
    def test_creation(self):
        """
        Same date/time constraints as occurrence.
        Attitionally, it is not valid to have a repeat_until without a rule.
        """
        e = self.bin_night
        d1 = date(2010,1,1)
        d2 = date(2010,1,2)
        d1min = datetimeify(d1, clamp='min')
        d1max = datetimeify(d1, clamp='max')
        d2min = datetimeify(d2, clamp='min')
        d2max = datetimeify(d2, clamp='max')
        t1 = time(9,00)
        t2 = time(10,00)
        
        dt1 = datetime.combine(d1, t1)
        dt2 = datetime.combine(d2, t2)

        #datetimes
        g = e.generators.create(event_start=dt1, event_end=dt2)
        self.ae(g.event_start, dt1)
        self.ae(g.event_end, dt2)

        g = e.generators.create(event_start=dt1)
        self.ae(g.event_start, dt1)
        self.ae(g.event_end, dt1)

        g = e.generators.create(event_start=d1min)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, d1max)

        
        #dates
        g = e.generators.create(event_start=d1)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, d1max)

        g = e.generators.create(event_start=d1, event_end=d2)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, d2max)

        #combos
        g = e.generators.create(event_start=dt1, event_end=d2)
        self.ae(g.event_start, dt1)
        self.ae(g.event_end, d2max)
        
        g = e.generators.create(event_start=d1, event_end=dt2)
        self.ae(g.event_start, d1min)
        self.ae(g.event_end, dt2)
        
        #missing event_start date
        self.assertRaises(TypeError, e.generators.create, **{'event_end':dt1})
        self.assertRaises(TypeError, e.generators.create, **{'event_end':d1})
        
        #invalid event_start value
        self.assertRaises(TypeError, e.generators.create, **{'event_start':t1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':t1, 'event_end':d1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':t1, 'event_end':dt1})

        #invalid event_end values
        self.assertRaises(TypeError, e.generators.create, **{'event_end':t1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':d1, 'event_end':t1})
        self.assertRaises(TypeError, e.generators.create, **{'event_start':dt1, 'event_end':t2})
        
        #event_start date later than event_end date
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':dt2, 'event_end':dt1})
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':d2, 'event_end':dt1})
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':d2, 'event_end':d1})
         
        self.assertRaises(AttributeError, e.generators.create, **{'event_start':dt1, 'event_end':dt2, 'repeat_until':dt2})
        
    def test_exceptions(self):
        """
        If an occurrence is deleted, that occurrence's datetimes are added to the generator's exceptions. That prevents
        deleted occurrences from being regenerated.
        
        If an occurrence's generator FK is changed, that occurrence is added as an exception to the generator. That
        prevents reassigned/detatched occurrences from being regenerated.
        
        If an occurrence's event FK is changed, that occurrence is NOT added as an exception to the generator. That
        allows occurrences to be reassigned to eventvariations and for the generator to still apply.
        """
        
        #try with deleting
        self.ae(self.weekly_generator.exceptions, {})

        byebye_occ = self.weekly_generator.occurrences.all()[0]
        sdate = byebye_occ.start
        byebye_occ.delete()
        
        #check it gets added to exceptions
        self.weekly_generator = self.weekly_generator.reload()
        self.ae(self.weekly_generator.exceptions.keys(), [sdate.isoformat(),])
        
        #check it doesn't come back
        self.weekly_generator.generate()
        self.ae(self.weekly_generator.event.occurrences.filter(start=sdate).count(), 0)
        
        #now try with generator reassignment
        byebye_occ2 = self.weekly_generator.occurrences.all()[0]
        sdate2 = byebye_occ2.start
        byebye_occ2.generator = None
        byebye_occ2.save()
        self.weekly_generator = self.weekly_generator.reload()
        self.ae(self.weekly_generator.exceptions.keys(), [sdate.isoformat(), sdate2.isoformat()])

        #now try with event reassignment (which should NOT affect exceptions)
        byebye_occ3 = self.weekly_generator.occurrences.all()[0]
        bb3_id = byebye_occ3.id
        sdate3 = byebye_occ3.start
        byebye_occ3.event = self.furniture_collection
        byebye_occ3.save()
        #check it DOESN'T get added to exceptions
        self.weekly_generator = self.weekly_generator.reload()
        self.ae(self.weekly_generator.exceptions.keys(), [sdate.isoformat(), sdate2.isoformat()])
        
        #but also that it doesn't get regenerated.
        self.weekly_generator.generate()
        bb3 = ExampleGOccurrence.objects.get(id=bb3_id)
        self.assertTrue(bb3 in self.weekly_generator.occurrences.all())
        self.ae(bb3.event, self.furniture_collection)
    
    def _reset_generator_changes(self):
        self.bin_night.occurrences.all().delete()
        self.changeable_generator = self.bin_night.generators.create(
            event_start=datetime(2010, 10, 1, 8, 30),
            event_end=datetime(2010, 10, 1, 9, 30),
            rule=self.weekly,
            repeat_until=datetime(2010, 10, 8)
        )
        #freak occurrence
        self.occ3 = self.changeable_generator.create_occurrence(start=datetime(2010, 10, 1, 13, 30), end=datetime(2010, 10, 1, 15, 30))

        self.ae(self.changeable_generator.occurrences.count(), 3)
        self.ae(self.changeable_generator.exceptions, {})
        self.original_occurrences = list(self.changeable_generator.occurrences.all())
        self.occ1 = self.original_occurrences[0] #freak one is [1]
        self.occ2 = self.original_occurrences[2]
        self.normal_occurrences = [self.occ1, self.occ2]

    def test_changes(self):
        """
        When you change a generator and save it, it updates existing occurrences according to the following:
        
        * If a repetition rule was changed:
            don't try to update occurrences, but run generate() to make the new occurrences.
        * If a repeat_until rule was changed:
            don't try to delete out-of-bounds occurrences, but run generate() to make the new occurrences.
            out-of-bounds occurrences are left behind.
            ie do nothing special :-)
            
        * If start date (or datetime) was changed:
            run the old rule, and timeshift all occurrences produced by the old rule.

        * Else if only start time was changed:
            update all the generator's occurrences that have the same start time.
            
        * If end date or (or datetime) was changed:
            run the (new) generator and update the end date of all occurrences produced by the rule
        
        * If only end time was changed:
            update all the generator's occurrences that have the same end time.
        """
        
                
        # let's change the timing and rule. The existing occurrences should be untouched.
        self._reset_generator_changes()
        daily = Rule.objects.create(frequency = "DAILY")
        self.changeable_generator.event_start=datetime(2010, 9, 30, 10, 30)
        self.changeable_generator.rule=daily
        self.changeable_generator.save()    
        new_occurrences = list(self.changeable_generator.occurrences.all())
        self.ae(len(new_occurrences), 12)
        for occ in self.normal_occurrences: #forget the freak one
            self.assertTrue(occ in new_occurrences)
            o = self.changeable_generator.occurrences.get(id=occ.id)
            self.ae(o.start.time(), time(8,30))
            self.ae(o.end.time(), time(9,30))
        
        # let's change the repeat_until rule to earlier. Nothing should be deleted.
        self._reset_generator_changes()
        self.changeable_generator.repeat_until = date(2010, 10, 1)
        self.changeable_generator.save()
        new_occurrences = list(self.changeable_generator.occurrences.all())
        self.ae(len(new_occurrences), 3)
        for occ in self.original_occurrences:
            self.assertTrue(occ in new_occurrences)
        
        #let's change the start date/time
        self._reset_generator_changes()
        self.changeable_generator.event_start = datetime(2010, 9, 30, 8, 45)
        self.changeable_generator.save()
        #reload the original occurrences. The times should be updated.
        occ1 = self.changeable_generator.occurrences.get(id=self.occ1.id)
        occ2 = self.changeable_generator.occurrences.get(id=self.occ2.id)
        occ3 = self.changeable_generator.occurrences.get(id=self.occ3.id)
        self.ae(occ1.start, datetime(2010, 9, 30, 8, 45))
        self.ae(occ2.start, datetime(2010, 10, 7, 8, 45))
        #freak occurrence is unaffected
        self.ae(occ3.start, datetime(2010, 10, 1, 13, 30))

        #let's change the start time only, first tweaking an occurrence date.
        self._reset_generator_changes()
        #change occurrence date (not time) - we expect the time to be updated by the generator change.
        self.occ1.start = datetime(2010, 9, 30, 8, 30)
        self.occ1.save()
        #change generator time (not date)
        self.changeable_generator.event_start = datetime(2010, 10, 1, 8, 45)
        self.changeable_generator.save()
        #reload the original occurrences. The times should be updated.
        occ1 = self.changeable_generator.occurrences.get(id=self.occ1.id)
        occ2 = self.changeable_generator.occurrences.get(id=self.occ2.id)
        occ3 = self.changeable_generator.occurrences.get(id=self.occ3.id)
        self.ae(occ1.start, datetime(2010, 9, 30, 8, 45))
        self.ae(occ2.start, datetime(2010, 10, 8, 8, 45))
        #freak occurrence is unaffected
        self.ae(occ3.start, datetime(2010, 10, 1, 13, 30))

        #let's change the end date/time
        self._reset_generator_changes()
        self.changeable_generator.event_end = datetime(2010, 10, 2, 9, 45)
        self.changeable_generator.save()
        #reload the original occurrences. The endtimes should be updated.
        occ1 = self.changeable_generator.occurrences.get(id=self.occ1.id)
        occ2 = self.changeable_generator.occurrences.get(id=self.occ2.id)
        occ3 = self.changeable_generator.occurrences.get(id=self.occ3.id)
        self.ae(occ1.end, datetime(2010, 10, 2, 9, 45))
        self.ae(occ2.end, datetime(2010, 10, 9, 9, 45))
        #freak occurrence is unaffected
        self.ae(occ3.end, datetime(2010, 10, 1, 15, 30))
        
        #let's change the end time only, first tweaking an occurrence date.
        self._reset_generator_changes()
        #change occurrence date (not time)
        self.occ1.end = datetime(2010, 10, 3, 9, 30)
        self.occ1.save()
        #change generator time (not date)
        self.changeable_generator.event_end = datetime(2010, 10, 1, 9, 45)
        self.changeable_generator.save()
        #reload the original occurrences. The times should be updated.
        occ1 = self.changeable_generator.occurrences.get(id=self.occ1.id)
        occ2 = self.changeable_generator.occurrences.get(id=self.occ2.id)
        occ3 = self.changeable_generator.occurrences.get(id=self.occ3.id)
        self.ae(occ1.end, datetime(2010, 10, 3, 9, 45))
        self.ae(occ2.end, datetime(2010, 10, 8, 9, 45))
        #freak occurrence is unaffected
        self.ae(occ3.end, datetime(2010, 10, 1, 15, 30))

        # if we change the rule so that times are shifted to match other occurrences then
        # all occurrences are kept.
        self._reset_generator_changes()
        self.changeable_generator.event_start = self.occ3.start
        self.changeable_generator.event_end = self.occ3.end
        self.changeable_generator.save()
        self.ae(self.changeable_generator.occurrences.count(), 3)
        #reload the original occurrences. The times should be updated.
        occ1 = self.changeable_generator.occurrences.get(id=self.occ1.id)
        occ2 = self.changeable_generator.occurrences.get(id=self.occ2.id)
        occ3 = self.changeable_generator.occurrences.get(id=self.occ3.id)
        self.ae(occ1.start, datetime(2010, 10, 1, 13, 30))
        self.ae(occ2.start, datetime(2010, 10, 8, 13, 30))
        self.ae(occ3.start, datetime(2010, 10, 1, 13, 30))
        self.ae(occ1.end, datetime(2010, 10, 1, 15, 30))
        self.ae(occ2.end, datetime(2010, 10, 8, 15, 30))
        self.ae(occ3.end, datetime(2010, 10, 1, 15, 30))
        self.assertTrue(occ3.id != occ1.id)
        
        #now updates should affect occ3 as well
        self.changeable_generator.event_start = datetime(2010, 9, 30, 13, 31)
        self.changeable_generator.save()
        #reload the original occurrences. The times should be updated.
        occ1 = self.changeable_generator.occurrences.get(id=self.occ1.id)
        occ2 = self.changeable_generator.occurrences.get(id=self.occ2.id)
        occ3 = self.changeable_generator.occurrences.get(id=self.occ3.id)
        self.ae(occ1.start, datetime(2010, 9, 30, 13, 31))
        self.ae(occ2.start, datetime(2010, 10, 7, 13, 31))
        self.ae(occ3.start, datetime(2010, 9, 30, 13, 31))

        """
        TODO: We need a special admin widget for entering the datetimes.
        """